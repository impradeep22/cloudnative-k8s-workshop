[{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/","title":"Cloud Native with Kubernetes","tags":[],"description":"","content":" CLOUD NATIVE WITH KUBERNETES Welcome Kubernetes is rapidly becoming the standard platform for running scalable applications on containers: the major companies around the world have adopted or are adopting this platform to orchestrate their container-based workloads. It is therefore essential to design and implement applications that correctly work on Kubernetes and that can take full advantage of its features.\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/010_introduction.html","title":"Introduction","tags":[],"description":"","content":" Learning Objectives ➡️ Basic Kubectl Commands\n➡️ Different Kubernetes Cluster Providers (Managed)\n➡️ Self Hosted Kubernetes Clusters (On-Premise/VM)\n➡️ Creating a Self Hosted Kuberenetes Cluster with K3D\n➡️ Deploying a Cloud Native Application with Kuberenetes\n➡️ Logging, Metrics \u0026amp; Troubleshooting\nWorkshop Structure This workshop is broken into the sections list below. Estimated time for completing the workshop is 2 hours 10 mins.​\n◻️ Basic Kubectl Commands (10 minutes) Basic Kubectl Commands\n◻️ Prerequisites (30 minutes) WSL Setup with Docker Installed​\n◻️ Kubernetes Setup (30 minutes) Installation of a Kubernetes Cluster using K3D\n◻️ Application Deployment (30 minutes)\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ➡️ Creating a Cloud-Native React Application\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ➡️ Deploying the application to Kuberenetes Cluster\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ➡️ Application access and testing\n◻️ Logging, Metrics \u0026amp; Troubleshooting (30 minutes)\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ➡️ Metrics Management using Prometheus\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ➡️ Log Management using ELK Stack\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/030_basic_kubectl_commands.html","title":"1. Basic Kubectl Commands","tags":[],"description":"","content":" Kubectl - Command Line Tool Kubernetes provides a command line tool for communicating with a Kubernetes cluster\u0026rsquo;s control plane, using the Kubernetes API.This tool is named kubectl. We can use kubectl to deploy applications, inspect and manage cluster resources, and view logs.\nkubectl is installable on a variety of Linux platforms, macOS and Windows. Refer the below link to install kubectl,\nInstall Kubectl\n➡️ Client and Server version information\nkubectl version ➡️ Cluster Information\nkubectl cluster-info ➡️ Supported API versions on the server\nkubectl api-versions ➡️ List Resources\nkubectl get nodes kubectl get nodes ➡️ Details of a specific resource\nkubectl describe node \u0026lt;nodename\u0026gt; kubectl describe pod \u0026lt;podname\u0026gt; ➡️ Create resource\nkubectl create -f \u0026lt;filename\u0026gt;"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/020_setup_prerequisites.html","title":"1. Setup Prerequisites","tags":[],"description":"","content":" Self-Paced Workshop Introduction Welcome to the self-guided setup section, where you will learn how to set everything to spin up a Kubernetes cluster from the start. ​\nThis workshop requires a Windows 10 2004 or Later/Ubuntu 20.04+ Machine to set up the necessary components to work through the workshop.\n Here is a preview of what we will be setting up as part of pre-requistes:\n➡️ Install WSL and Linux Distribution - Ubuntu 20.04 (Windows)\n➡️ Install Docker (Linux)\n➡️ Install Google-Chrome (Linux)\n➡️ Install GWSL (Windows)\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/040_create_cluster.html","title":"3. Create a Kubernetes Cluster","tags":[],"description":"","content":"This section will guide you through the installation of K3D, a rancher project and setup an instance of multi-node lightweight kubernetes cluster based on K3S.\nHere is a preview of the steps involved:\n➡️ Install K3D\n➡️ Create a Kubernetes Cluster using K3D utility\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/050_deploy_app.html","title":"4. Deploy an Application","tags":[],"description":"","content":" About the Application This workshop deploys a simple netflix clone that allows one to see trailers of movies. It\u0026rsquo;s built on top of React - a javascript framework for the UI elements.\n "},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/060_logging_metrics.html","title":"5. Logging, Metrics &amp; Troubleshooting","tags":[],"description":"","content":" Logging, Metrics \u0026amp; Troubleshooting Traditional logging and metrics tools are designed for stable infrastructure and application deployments. Cloud native environments, on the other hand, are highly dynamic.\nTraditional systems rely on anchors like IP or machine addresses, but in a cloud native setting, these factors are continuously changing. To keep track of all this, we need a new breed of logging and monitoring system, one that is cloud native.\nHere is a preview of what we will be setting up as part of this section:\n➡️ Metrics Management using Prometheus\n➡️ Log Management using Elastic Stack\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/040_create_cluster/40_install_k3d.html","title":"1. Install K3D","tags":[],"description":"","content":" Install K3D k3d is a lightweight wrapper to run k3s (Rancher Lab’s minimal Kubernetes distribution) in docker.\nk3d makes it very easy to create single- and multi-node k3s clusters in docker, e.g. for local development on Kubernetes.\n➡️ Install K3D\nwget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash ➡️ Validate K3D Installation\nk3d version Let\u0026rsquo;s move to the next section\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/020_setup_prerequisites/20_setup_wsl.html","title":"1. Install WSL and Linux","tags":[],"description":"","content":" Windows Subsystem for Linux (WSL)  You must be running Windows 10 version 2004 and higher (Build 19041 and higher) or Windows 11. We highly recommend you to go to the WSL Installation to get started with WSL environment.\n The Windows Subsystem for Linux lets developers run a GNU/Linux environment directly on Windows, unmodified, without the overhead of a traditional virtual machine or dualboot setup.\nInstall Windows Subsytem for Linux (WSL) ➡️ Powershell/CMD\nwsl --install Install Linux environment (Ubuntu 20.04) ➡️ Powershell/CMD\nwsl --install -d Ubuntu-20.04"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/050_deploy_app/50_create_image.html","title":"1. Create Docker Image","tags":[],"description":"","content":" Create Docker Image For deployment, we’ll package our application within a container. Kubernetes supports many different container engines, here we’ll use Docker (which is widely used).\nThe Dockerfile used instructs docker how to build images step by step.\n➡️ Fetch application source\ngit clone https://github.com/karthick-kk/netflix-clone ➡️ Build Image\ncd netflix-clone docker build -t netflix-clone:1.0 . ➡️ Push the Image to Docker Registry\ndocker tag netflix-clone:1.0 devregistry:30500/netflix-clone:latest docker push devregistry:30500/netflix-clone:latest"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/060_logging_metrics/60_prometheus_stack_monitoring.html","title":"1. Monitoring using Prometheus Stack","tags":[],"description":"","content":" Monitoring Using Prometheus Stack Prometheus collects and stores its metrics as time series data, i.e. metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels.\nPrometheus scrapes metrics from instrumented jobs, either directly or via an intermediary push gateway for short-lived jobs. It stores all scraped samples locally and runs rules over this data to either aggregate and record new time series from existing data or generate alerts. Grafana or other API consumers can be used to visualize the collected data.\nBelow are steps to install Prometheus Stack in a Kubernetes Cluster\n➡️ Create Monitoring Namespace\nkubectl create namespace monitoring ➡️ Add Prometheus Stack Chart Repository\nhelm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo update ➡️ Helm Install Prometheus Stack\nhelm install prometheus-stack prometheus-community/kube-prometheus-stack -n monitoring ➡️ Prometheus Stack Pod Status\nkubectl -n monitoring get nodes -o wide ➡️ Port-forward to localhost\nkubectl -n monitoring port-forward service/prometheus-stack-kube-prom-prometheus 9090 kubectl -n monitoring port-forward service/prometheus-stack-grafana 9091:80 ➡️ GUI to Prometheus and Grafana\nhttp://localhost:9090 http://localhost:9091"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/020_setup_prerequisites/21_install_docker.html","title":"2. Install Docker","tags":[],"description":"","content":" Install Docker Although Docker is not needed as a container runtime in Kubernetes, it still has a role to play in the Kubernetes ecosystem, and in your workflow. Docker is still going strong as a tool for developing and building container images, as well as running them locally.\n➡️ Install docker via package manager\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install docker.io -y ➡️ Add docker daemon to startup\necho \u0026#39;# Start Docker (if not already running) RUNNING=$(ps aux | grep dockerd | grep -v grep) if [ -z \u0026#34;$RUNNING\u0026#34; ]; then sudo dockerd \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; disown fi\u0026#39; \u0026gt;\u0026gt; ~/.bashrc ➡️ Add USER to sudoers\necho \u0026#34;$USER ALL=(ALL) NOPASSWD:ALL\u0026#34; | sudo tee -a /etc/sudoers.d/$USER ➡️ Add USER to docker group\nsudo usermod -aG docker $USER ➡️ Reboot WSL [Powershell/CMD]\nwsl -t Ubuntu-20.04 wsl -d Ubuntu-20.04"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/060_logging_metrics/62_elastic_stack_logging.html","title":"2. Logging using Elastic Stack","tags":[],"description":"","content":" Logging Using Elastic Stack \u0026ldquo;ELK\u0026rdquo; is the acronym for three open source projects: Elasticsearch, Logstash, and Kibana. Elasticsearch is a search and analytics engine. Logstash is a server‑side data processing pipeline that ingests data from multiple sources simultaneously, transforms it, and then sends it to a \u0026ldquo;stash\u0026rdquo; like Elasticsearch. Kibana lets users visualize data with charts and graphs in Elasticsearch.\nThe Elastic Stack is the next evolution of the ELK Stack.\nBelow are steps to install Elastic Stack in a Kubernetes Cluster\n➡️ Create Logging Namespace\nkubectl create namespace logging ➡️ Add Elastic Chart Repository\nhelm repo add elastic https://helm.elastic.co helm repo update ➡️ Install elasticsearch chart\nhelm install elasticsearch elastic/elasticsearch -n logging ➡️ Install filebeat chart\nhelm install filebeat elastic/filebeat -n logging ➡️ Install logging chart\nhelm install kibana elastic/kibana -n logging ➡️ Port-forward to localhost\nkubectl -n logging port-forward svc/elasticsearch-master 9200:9200 kubectl -n logging port-forward svc/kibana-kibana 5601:5601 ➡️ GUI to Prometheus and Grafana\nhttp://localhost:9200 http://localhost:5601"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/030_setup_prerequisites/32_install_chrome.html","title":"3. Install Google Chrome","tags":[],"description":"","content":" Install Google Chrome Chrome is available for Linux and this page shows you where to download it from and how to install it. It is essential to have a graphical browser installed for web development.\n➡️ Download Chrome\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb ➡️ Install Chrome\nsudo apt install ./google-chrome-stable_current_amd64.deb -y"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/030_setup_prerequisites/33_install_gwsl.html","title":"4. Install GWSL","tags":[],"description":"","content":" Install GWSL GWSL is an XServer that lets you easily run graphical Linux apps on Windows 10. GWSL stands for Graphical WSL.\n➡️ Download and Install GWSL\nGithub Source\n➡️ Setup Remote Display\nexport DISPLAY=$(ip -4 route | awk \u0026#39;{ if ($1~/default/) print $3 }\u0026#39;):0.0 export PULSE_SERVER=tcp:$(ip -4 route | awk \u0026#39;{ if ($1~/default/) print $3 }\u0026#39;)  ➡️ Update profile to persist the configuration\necho \u0026#34;export DISPLAY=\\$(ip -4 route | awk \u0026#39;{ if (\\$1~/default/) print \\$3 }\u0026#39;):0.0 export PULSE_SERVER=tcp:\\$(ip -4 route | awk \u0026#39;{ if (\\$1~/default/) print \\$3 }\u0026#39;)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/050_deploy_app/54_create_k8s_deployment.html","title":"2. Create Deployment","tags":[],"description":"","content":" Create a Kubernetes Deployment We create a deployment due to the application being stateless. For applications that persists data, a statefulset is preferred to store the data across all the nodes.\n ➡️ Create a Kubernetes Deployment from manifests\nkubectl apply -f manifests ➡️ Verify the deployment and service\nkubectl get deployment netflix-clone kubectl get service netflix-clone-service"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/040_create_cluster/42_create_cluster.html","title":"2. Create Kubernetes Cluster","tags":[],"description":"","content":" Setup your first Kubernetes Cluster using K3D ➡️ 1. Create Kubernetes Cluster\nCreate a cluster named devcluster with just a single master node and 3 worker nodes. We will disable the auto creation of load balancer service and inbuilt traefik ingress controller. A registry node named devregistry will also be created as part of the cluster creation.\nAdditionally, we will add up a third party Load Balancer(MetalLB) and Nginx Ingress Controller to the cluster to simulate and access like a realtime kubernetes environment.\nk3d cluster create devcluster --agents 3 --k3s-arg \u0026#34;--disable=traefik@server:0\u0026#34; --k3s-arg \u0026#34;--disable=servicelb@server:0\u0026#34; --no-lb --wait --registry-create devregistry:30500 ➡️ 2. Install Kubectl\ncurl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; sudo mv kubectl /usr/local/bin ➡️ 3. Explore Cluster Resources\nk3d cluster list k3d kubeconfig get devcluster \u0026gt; ~/.kube/config export KUBECONFIG=~/.kube/config kubectl get nodes -o wide ➡️ 4. Update /etc/hosts for local registry access\necho \u0026#34;127.0.0.1 devregistry\u0026#34; | sudo tee -a /etc/hosts ➡️ 5. Install MetalLB\nkubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.11.0/manifests/metallb.yaml ➡️ 5.1 Configure MetalLB\nsudo apt install jq -y cidr_block=$(docker network inspect k3d-devcluster | jq \u0026#39;.[0].IPAM.Config[0].Subnet\u0026#39; | tr -d \u0026#39;\u0026#34;\u0026#39;) base_addr=${cidr_block%???} first_addr=$(echo $base_addr | awk -F\u0026#39;.\u0026#39; \u0026#39;{print $1,$2,$3,240}\u0026#39; OFS=\u0026#39;.\u0026#39;) range=$first_addr/29 ➡️ 5.2 Create MetalLB ConfigMap\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - $range EOF ➡️ 6. Install Nginx Ingress Controller\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.2/deploy/static/provider/cloud/deploy.yaml"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/050_deploy_app/55_create_ingress.html","title":"3. Create Ingress for External Access","tags":[],"description":"","content":" Create Ingress for External Access The deployment we created will not be accessible from outside the cluster, unless we use a NodePort service or LoadBalancer or Ingress route. We will create an Ingress object to access the application through a fake DNS\n➡️ Add a fake DNS entry\nLBIP=$(kubectl describe svc ingress-nginx-controller -n ingress-nginx|grep \u0026#34;Ingress:\u0026#34;|awk \u0026#39;{print $NF}\u0026#39;) echo \u0026#34;$LBIP netflix-clone.kcdchennai.in\u0026#34; | sudo tee -a /etc/hosts ➡️ Create an Ingress\nkubectl create ingress netflix-clone-ingress --rule=\u0026#34;netflix-clone.kcdchennai.in/*=netflix-clone-service:80\u0026#34; --class=nginx To further secure the endpoint, tls can be enabled for the ingress after creating necessary TLS certificates.\n "},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/050_deploy_app/56_conclusion.html","title":"Conclusion","tags":[],"description":"","content":"Cheers! We got our first application going live in the cluster that we created. Kindly refer to the KCNA page for further learning and certification in this space.\n"},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/099_survey.html","title":"Survey","tags":[],"description":"","content":" Survey To help us improve this workshop, please take some time to fill out the  Survey  "},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/030_setup_prerequisites.html","title":"030_setup_prerequisites","tags":[],"description":"","content":""},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/categories.html","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://kcdchennai.github.io/cloudnative-k8s-workshop/tags.html","title":"Tags","tags":[],"description":"","content":""}]